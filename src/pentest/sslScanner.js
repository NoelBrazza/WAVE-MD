const tls = require('tls');
const https = require('https');
const { Buffer } = require('buffer');
const { URL } = require('url');
const zlib = require('zlib');

// Example of known vulnerabilities for demonstration
const knownVulnerabilities = {
    'FREAK': 'https://www.cve.org/CVERecord?id=CVE-2015-0204',
    'LOGJAM': 'https://www.cve.org/CVERecord?id=CVE-2015-4000',
    'DROWN': 'https://www.cve.org/CVERecord?id=CVE-2016-0800',
    'CRIME': 'https://www.cve.org/CVERecord?id=CVE-2012-4929',
    'Padding Oracle': 'https://www.cve.org/CVERecord?id=CVE-2015-7501',
    'Curveball': 'https://www.cve.org/CVERecord?id=CVE-2020-0601'
};

// Function to check POODLE vulnerability
async function checkForPOODLE(hostname, port) {
    return new Promise((resolve, reject) => {
        const socket = tls.connect(port, hostname, { secureProtocol: 'SSLv3_method' }, () => {
            console.log('POODLE Vulnerability Detected: SSLv3 supported');
            socket.end();
            resolve();
        });

        socket.on('error', (err) => {
            if (err.code === 'UNSUPPORTED_PROTOCOL') {
                console.log('POODLE Vulnerability Not Detected: SSLv3 not supported');
                resolve();
            } else {
                console.error('Error while checking POODLE:', err.message);
                reject(err.message);
            }
        });
    });
}

// Function to check Heartbleed vulnerability
async function checkForHeartbleed(hostname, port) {
    return new Promise((resolve, reject) => {
        const payload = Buffer.from('0000', 'hex').toString('utf8');
        const heartbeatPayload = Buffer.concat([
            Buffer.from('0100', 'hex'),
            Buffer.from('0000', 'hex'),
            Buffer.from(payload, 'utf8')
        ]);

        const socket = tls.connect(port, hostname, { rejectUnauthorized: false }, () => {
            socket.write(heartbeatPayload);
        });

        socket.on('data', (data) => {
            if (data.toString().includes('Heartbleed')) {
                console.log('Heartbleed Vulnerability Detected');
            } else {
                console.log('Heartbleed Vulnerability Not Detected');
            }
            socket.end();
            resolve();
        });

        socket.on('error', (err) => {
            console.error('Error while checking Heartbleed:', err.message);
            reject(err.message);
        });
    });
}

// Function to check FREAK vulnerability
async function checkForFREAK(hostname, port) {
    return new Promise((resolve, reject) => {
        const ciphers = [
            'RSA_WITH_RC4_128_SHA',
            'RSA_WITH_RC4_128_MD5'
        ];

        ciphers.forEach(cipher => {
            const socket = tls.connect(port, hostname, { ciphers: cipher }, () => {
                console.log(`FREAK Vulnerability Detected: Cipher ${cipher} supported`);
                socket.end();
            });

            socket.on('error', (err) => {
                console.log(`FREAK Vulnerability Not Detected: Cipher ${cipher} not supported`);
                socket.destroy();
            });
        });

        resolve();
    });
}

// Function to check LOGJAM vulnerability
async function checkForLOGJAM(hostname, port) {
    return new Promise((resolve, reject) => {
        const weakDHParameters = [
            '1024',
            '2048'
        ];

        weakDHParameters.forEach(param => {
            const socket = tls.connect(port, hostname, { dhparam: param }, () => {
                console.log(`LOGJAM Vulnerability Detected: DH parameter ${param} supported`);
                socket.end();
            });

            socket.on('error', (err) => {
                console.log(`LOGJAM Vulnerability Not Detected: DH parameter ${param} not supported`);
                socket.destroy();
            });
        });

        resolve();
    });
}

// Function to check DROWN vulnerability
async function checkForDROWN(hostname, port) {
    return new Promise((resolve, reject) => {
        const socket = tls.connect(port, hostname, { secureProtocol: 'SSLv2_method' }, () => {
            console.log('DROWN Vulnerability Detected: SSLv2 supported');
            socket.end();
        });

        socket.on('error', (err) => {
            if (err.code === 'UNSUPPORTED_PROTOCOL') {
                console.log('DROWN Vulnerability Not Detected: SSLv2 not supported');
                resolve();
            } else {
                console.error('Error while checking DROWN:', err.message);
                reject(err.message);
            }
        });
    });
}

// Function to check CRIME vulnerability
async function checkForCRIME(hostname, port) {
    return new Promise((resolve, reject) => {
        const payload = 'Hello World!';
        const compressedPayload = zlib.deflateSync(payload);

        const request = https.request({
            hostname: hostname,
            port: port,
            method: 'GET',
            path: '/path',
            headers: {
                'Cookie': `session=${compressedPayload.toString('base64')}`
            }
        }, (res) => {
            res.on('data', (chunk) => {
                if (chunk.toString().includes(payload)) {
                    console.log('CRIME Vulnerability Detected');
                } else {
                    console.log('CRIME Vulnerability Not Detected');
                }
                resolve();
            });
        });

        request.on('error', (err) => {
            console.error('Error while checking CRIME:', err.message);
            reject(err.message);
        });

        request.end();
    });
}

// Function to check Padding Oracle vulnerability
async function checkForPaddingOracle(hostname, port) {
    return new Promise((resolve, reject) => {
        const payload = Buffer.from('00', 'hex');
        const request = https.request({
            hostname: hostname,
            port: port,
            method: 'POST',
            path: '/path',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Content-Length': payload.length
            }
        }, (res) => {
            res.on('data', (chunk) => {
                if (chunk.toString().includes('Padding error')) {
                    console.log('Padding Oracle Vulnerability Detected');
                } else {
                    console.log('Padding Oracle Vulnerability Not Detected');
                }
                resolve();
            });
        });

        request.on('error', (err) => {
            console.error('Error while checking Padding Oracle:', err.message);
            reject(err.message);
        });

        request.write(payload);
        request.end();
    });
}

// Function to check Curveball vulnerability
async function checkForCurveball(hostname, port) {
    return new Promise((resolve, reject) => {
        const testVectors = [
            { key: 'TestVector1' },
            { key: 'TestVector2' }
        ];

        testVectors.forEach(test => {
            const socket = tls.connect(port, hostname, { secureProtocol: 'TLSv1_2_method', ecdhCurve: test.key }, () => {
                console.log(`Curveball Vulnerability Detected: Test vector ${test.key} supported`);
                socket.end();
            });

            socket.on('error', (err) => {
                console.log(`Curveball Vulnerability Not Detected: Test vector ${test.key} not supported`);
                socket.destroy();
            });
        });

        resolve();
    });
}

// Function to perform SSL/TLS scan on a given URL
async function scanSSL(url) {
    try {
        const parsedUrl = new URL(url);
        const hostname = parsedUrl.hostname;
        const port = parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80);

        console.log(`Scanning SSL/TLS vulnerabilities for ${hostname}:${port}`);

        // Perform checks
        await checkCertificateValidity(hostname, port);
        await checkProtocolSupport(hostname, port);
        await checkCipherSuites(hostname, port);
        await checkForKnownVulnerabilities(hostname, port);
        await checkForSSLv3(hostname, port);
        await checkForPOODLE(hostname, port);
        await checkForHeartbleed(hostname, port);
        await checkForFREAK(hostname, port);
        await checkForLOGJAM(hostname, port);
        await checkForDROWN(hostname, port);
        await checkForCRIME(hostname, port);
        await checkForPaddingOracle(hostname, port);
        await checkForCurveball(hostname, port);

    } catch (error) {
        console.error('Error during SSL scan:', error);
    }
}

// Function to check certificate validity
async function checkCertificateValidity(hostname, port) {
    return new Promise((resolve, reject) => {
        const options = {
            host: hostname,
            port: port,
            rejectUnauthorized: false,
        };

        const req = https.request(options, (res) => {
            const cert = res.connection.getPeerCertificate();
            if (cert && cert.valid_to) {
                console.log(`Certificate valid to: ${cert.valid_to}`);
            } else {
                console.log('Certificate is not valid or could not be retrieved.');
            }
            resolve();
        });

        req.on('error', (e) => {
            console.error('Error checking certificate validity:', e.message);
            reject(e.message);
        });

        req.end();
    });
}

// Function to check protocol support
async function checkProtocolSupport(hostname, port) {
    // Placeholder implementation for checking supported protocols
    console.log('Protocol support check is not implemented yet.');
}

// Function to check cipher suites
async function checkCipherSuites(hostname, port) {
    // Placeholder implementation for checking supported cipher suites
    console.log('Cipher suite check is not implemented yet.');
}

// Function to check for known vulnerabilities
async function checkForKnownVulnerabilities(hostname, port) {
    console.log('Known vulnerabilities:');
    for (const [vuln, url] of Object.entries(knownVulnerabilities)) {
        console.log(`${vuln}: ${url}`);
    }
}

// Export the function for use in other files
module.exports = { scanSSL };
